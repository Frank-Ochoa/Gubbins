/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. gub.jj */
/*@egen*/PARSER_BEGIN(Gubbins)

package Gubbins.Parser;
import ast.*;
import java.util.LinkedList;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.Iterator;
import java.util.List;

public class Gubbins/*@bgen(jjtree)*/implements GubbinsTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTGubbinsState jjtree = new JJTGubbinsState();

/*@egen*/
}

PARSER_END(Gubbins)


SKIP :    //what in our programming lang can be treated as white space
	  //this says skip spaces or tabs or next lines   | = or
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN : /* RESERVED WORDS*/
{
        <WHILE : "while">
    |   <IF : "if">
    |   <TRUE: "true" >
    |   <FALSE: "false" >
    |   <FOR: "for" >
    |   <IN: "in" >
    |   <RANGE: "range" >
    |   <PRINT: "print" >
    |   <DO:    "do" >
    |   <FUNC: "func" >
    |   <ARROW: "->">
    |   <REC:   "rec">
    |   <RETURN: "return">
}

TOKEN : /* TYPES */
{
        <TYPE_INT : "int">
    |   <TYPE_DOUBLE: "double">
    |   <TYPE_BOOLEAN: "bool">
    |   <TYPE_ARRAY : "arr" >
}

TOKEN : /* IDENTIFIERS */ //a token is one unit of information
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* > //this says an ID has to start with a 						        letter followed by 0 or more letters or 						digits
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

TOKEN : /* LITERALS */
{
        < INTEGER_LITERAL:  (<DIGIT>)+ >    //careful with * and +
   |    < DOUBLE_LITERAL: <INTEGER_LITERAL> "." <INTEGER_LITERAL> >
}



TOKEN : /* OPERATORS*/
{
        <PLUS : "+">
    |   <MULT : "*">
    |   <DIV : "/">
    |   <SUB : "-">
    |   <ASSIGN_EQUALS : ":=">
    |   <SEMI : ";">
    |   <LCURLY : "{">
    |   <RCURLY : "}">
    |   <LPAREN : "(" >
    |   <RPAREN : ")" >
    |   <COMMA : "," >
    |   <DOT :  "." >
    |   <LBRACK: "[">
    |   <RBRACK: "]">
}


TOKEN : /* BOOLEAN CONDITIONALS */
{
	<GREATER_THAN : ">" >
	|
	<GREATER_THAN_EQTO : ">=" >
	|
	<LESS_THAN : "<" >
	|
	<LESS_THAN_EQTO : "<=" >
	|
	<EQ_TO : "=" >
	|
	<NOT_EQ_TO : "!=" >
}

/** Top level production. */
List<IASTStatement> Input() :
{/*@bgen(jjtree) Input */
    SimpleNode jjtn000 = new SimpleNode(JJTINPUT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    List<IASTStatement> result;
}
{/*@bgen(jjtree) Input */
    try {
/*@egen*/
    result = Statements()
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTStatement Statement() :
{/*@bgen(jjtree) Statement */
    SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTStatement s;
}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    LOOKAHEAD(2)

	        s = Assignment()  <SEMI>/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn000, true);
                                            jjtc000 = false;
                                          }
/*@egen*/  { return s; }
            |   <PRINT> s = Print() <SEMI>/*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn000, true);
                                                      jjtc000 = false;
                                                    }
/*@egen*/          { return s; }
            |   s = DoWhileLoop()/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn000, true);
                                               jjtc000 = false;
                                             }
/*@egen*/            { return s; }
            |   s = ForLoop()/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/              { return s; }
            |   s = WhileLoop()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/         { return s; }
            |   s = If()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/                { return s; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

List<IASTStatement> Statements() :
{/*@bgen(jjtree) Statements */
    SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTStatement s;
    LinkedList<IASTStatement> result = new LinkedList<IASTStatement>();
}
{/*@bgen(jjtree) Statements */
    try {
/*@egen*/
    (s = Statement() { result.add(s); })+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTStatement FunctionStatement() :
{/*@bgen(jjtree) FunctionStatement */
    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTStatement s;
}
{/*@bgen(jjtree) FunctionStatement */
    try {
/*@egen*/
    LOOKAHEAD(2)

	        s = Assignment()  <SEMI>/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn000, true);
                                            jjtc000 = false;
                                          }
/*@egen*/  { return s; }
            |   <PRINT> s = Print() <SEMI>/*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn000, true);
                                                      jjtc000 = false;
                                                    }
/*@egen*/          { return s; }
            |   s = DoWhileLoop()/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn000, true);
                                               jjtc000 = false;
                                             }
/*@egen*/            { return s; }
            |   s = ForLoop()/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/              { return s; }
            |   s = WhileLoop()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/         { return s; }
            |   s = If()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/                { return s; }
            |   s = Return() <SEMI>/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                               }
/*@egen*/            {return s; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

List<IASTStatement> FunctionStatements() :
{/*@bgen(jjtree) FunctionStatements */
    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONSTATEMENTS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTStatement s;
    LinkedList<IASTStatement> result = new LinkedList<IASTStatement>();
}
{/*@bgen(jjtree) FunctionStatements */
    try {
/*@egen*/
    (s = FunctionStatement() { result.add(s); })+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

While WhileLoop() :
{/*@bgen(jjtree) WhileLoop */
    SimpleNode jjtn000 = new SimpleNode(JJTWHILELOOP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    List<IASTStatement> stmts;
    IASTExpr expr;
}
{/*@bgen(jjtree) WhileLoop */
    try {
/*@egen*/
    <WHILE> <LPAREN> expr = Expression() <RPAREN>
    <LCURLY>
        stmts = Statements()
    <RCURLY>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new While(expr, stmts); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

For ForLoop() :
{/*@bgen(jjtree) ForLoop */
    SimpleNode jjtn000 = new SimpleNode(JJTFORLOOP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    List<IASTStatement> stmts;
    IASTExpr expr;
    Token t;
}
{/*@bgen(jjtree) ForLoop */
    try {
/*@egen*/
    <FOR> t = <IDENTIFIER> <IN> <RANGE> expr = Expression()
    <LCURLY>
        stmts = Statements()
    <RCURLY>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new For(new Identifier(t.image), expr, stmts); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTStatement Print() :
{/*@bgen(jjtree) Print */
    SimpleNode jjtn000 = new SimpleNode(JJTPRINT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr e;
}
{/*@bgen(jjtree) Print */
         try {
/*@egen*/
	 e = Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return new Print(e); }/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

IASTExpr Expression() :
{/*@bgen(jjtree) Expression */
    SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr e;
}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    e = ConditionalExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ { return e; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTExpr ConditionalExpression() :
{/*@bgen(jjtree) ConditionalExpression */
    SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONALEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr result, b;
}
{/*@bgen(jjtree) ConditionalExpression */
    try {
/*@egen*/
    result = AdditiveExpression()
    (
        <LESS_THAN> b = AdditiveExpression() {result = new LessThan(result, b);}
        | <GREATER_THAN> b = AdditiveExpression() {result = new GreaterThan(result, b);}
        // And can do other conditionals under this if need be
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {return result;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTExpr AdditiveExpression() :
{/*@bgen(jjtree) AdditiveExpression */
    SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr result, b;
}
{/*@bgen(jjtree) AdditiveExpression */
    try {
/*@egen*/
    result = MultiplicativeExpression()
    (

            <PLUS> b = MultiplicativeExpression() {result = new Plus(result, b);}
        |    <SUB> b = MultiplicativeExpression() {result = new Sub(result, b);}

    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTExpr MultiplicativeExpression() :
{/*@bgen(jjtree) MultiplicativeExpression */
    SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr result, b;
}
{/*@bgen(jjtree) MultiplicativeExpression */
    try {
/*@egen*/
    result = RecordAccessExprssion()
    (
           <MULT> b = RecordAccessExprssion() {result = new Mult(result, b);}
        |  <DIV>  b = RecordAccessExprssion() {result = new Div(result, b); }

    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTExpr RecordAccessExprssion () :
{/*@bgen(jjtree) RecordAccessExprssion */
    SimpleNode jjtn000 = new SimpleNode(JJTRECORDACCESSEXPRSSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr result;
    Token index;
}
{/*@bgen(jjtree) RecordAccessExprssion */
    try {
/*@egen*/
    result = ArrayIndexExpression()
     (
        <DOT> index = <IDENTIFIER> {result = new RecordAccess(result, index.image);}
     )?/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTExpr ArrayIndexExpression() :
{/*@bgen(jjtree) ArrayIndexExpression */
    SimpleNode jjtn000 = new SimpleNode(JJTARRAYINDEXEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr result;
    IASTExpr index;
    List<IASTExpr> indices = new LinkedList<IASTExpr>();
}
{/*@bgen(jjtree) ArrayIndexExpression */
    try {
/*@egen*/
    result = AtomicExpression()
    (
        <LBRACK> index = Expression() {indices.add(index);} <RBRACK>
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        if(indices.isEmpty())
        {
            return result;
        }
        else
        {
            return new ArrayIndex(result, indices);
        }
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

IASTExpr AtomicExpression() :
{/*@bgen(jjtree) AtomicExpression */
    SimpleNode jjtn000 = new SimpleNode(JJTATOMICEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr e;
    Token t;
}
{/*@bgen(jjtree) AtomicExpression */
    try {
/*@egen*/
    LOOKAHEAD(1)
        t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/   { return new Int(Integer.parseInt(t.image)); }
    |   t = <DOUBLE_LITERAL>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/    { return new Dble(Double.parseDouble(t.image)); }
    |   t = <IDENTIFIER>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/        { return new Identifier(t.image); }
    |   <TRUE>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/                  { return new Bool(true); }
    |   <FALSE>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/                 { return new Bool(false); }
    |  e = Array()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/              { return e; }
    |  e = Function()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/           { return e; }
    |  e = Record()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/             { return e; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTStatement Assignment() :
{/*@bgen(jjtree) Assignment */
    SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    IASTType x = null;
    List<IASTExpr> indices = new LinkedList <IASTExpr>();
    IASTExpr index;
    IASTExpr e = null;
}
{/*@bgen(jjtree) Assignment */
   try {
/*@egen*/
   (x = FunctionType())? t = <IDENTIFIER> (<LBRACK> index = Expression() <RBRACK> { indices.add(index); })*  (<ASSIGN_EQUALS> e = Expression())?/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {
     if(x == null && e == null)
     {
        throw new ParseException("You done goofed, GL");
     }
     else if(x != null && e == null)
     {
        return new Declaration(x, new Identifier(t.image), indices);
     }
     else if(x == null && e != null)
     {
        return new Assignment(new Identifier(t.image), e, indices);
     }
     else
     {
        return new DeclareAssign(x, new Identifier(t.image), e, indices);
     }
   }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

IASTType FunctionType() :
{/*@bgen(jjtree) FunctionType */
    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONTYPE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTType t;
    IASTType result;
}
{/*@bgen(jjtree) FunctionType */
    try {
/*@egen*/
    result = Type()
    (
        <ARROW> t = Type() {return new TypeFunction(result, t);}
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {return result;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IASTType Type() :
{/*@bgen(jjtree) Type */
    SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTType t;
}
{/*@bgen(jjtree) Type */
     try {
/*@egen*/
     t = AtomicType()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/   {return t;}
     | <TYPE_ARRAY> t = Type()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/      {return new TypeArray(t);}/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}


IASTType AtomicType() :
{/*@bgen(jjtree) AtomicType */
     SimpleNode jjtn000 = new SimpleNode(JJTATOMICTYPE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     IASTType t;
     Token ident;
     List<IASTType> args = new LinkedList<IASTType>();
     List<Identifier> idents = new LinkedList<Identifier>();
     Map<Identifier, IASTType> record = new LinkedHashMap<Identifier, IASTType>();
}
{/*@bgen(jjtree) AtomicType */
         try {
/*@egen*/
         <TYPE_INT>/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/               {return TypeInt.INT;}
    |    <TYPE_DOUBLE>/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/            {return TypeDouble.DOUBLE;}
    |    <TYPE_BOOLEAN>/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/           {return TypeBoolean.BOOLEAN;}
    | <LPAREN> t = Type() ident = <IDENTIFIER> {args.add(t); idents.add(new Identifier(ident.image));}
         (<COMMA> t = Type() ident = <IDENTIFIER> {args.add(t); idents.add(new Identifier(ident.image));})* <RPAREN>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/
         {

         Iterator<Identifier> it1 = idents.iterator();
         Iterator<IASTType> it2 = args.iterator();
         while(it1.hasNext() && it2.hasNext())
         {
            record.put(it1.next(), it2.next());
         }

         return new TypeRecord(record);
         }/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

// Do this as an assignment
Array Array() :
{/*@bgen(jjtree) Array */
    SimpleNode jjtn000 = new SimpleNode(JJTARRAY);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTExpr e;
    IASTType t;
    List<IASTExpr> rhs = new LinkedList<IASTExpr>();
}
{/*@bgen(jjtree) Array */
   try {
/*@egen*/
   t = Type() <LPAREN> e = Expression() { rhs.add(e); } (<COMMA> e = Expression() {rhs.add(e);})* <RPAREN>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/

   {return new Array(t, rhs);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

DoWhile DoWhileLoop() :
{/*@bgen(jjtree) DoWhileLoop */
    SimpleNode jjtn000 = new SimpleNode(JJTDOWHILELOOP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    List<IASTStatement> stmts;
    IASTExpr expr;
}
{/*@bgen(jjtree) DoWhileLoop */
    try {
/*@egen*/
    <DO>
    <LCURLY>
        stmts = Statements()
    <RCURLY>
    <WHILE> <LPAREN> expr = Expression() <RPAREN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return new DoWhile(expr, stmts);}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

If If() :
{/*@bgen(jjtree) If */
    SimpleNode jjtn000 = new SimpleNode(JJTIF);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    List<IASTStatement> stmts;
    IASTExpr condt;
}
{/*@bgen(jjtree) If */
    try {
/*@egen*/
    <IF> <LPAREN> condt = Expression() <RPAREN>
    <LCURLY>
        stmts = Statements()
    <RCURLY>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {return new If(condt, stmts);}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Record Record() :
{/*@bgen(jjtree) Record */
    SimpleNode jjtn000 = new SimpleNode(JJTRECORD);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    // Can compute the type of the record based on whats in there
    // int a := 12, int b := 15; etc
    List<IASTStatement> assigns = new LinkedList<IASTStatement>();
    IASTStatement stmt;
}
{/*@bgen(jjtree) Record */
    try {
/*@egen*/
    <REC> <LPAREN> stmt = Assignment() {assigns.add(stmt);} (<COMMA> stmt = Assignment() {assigns.add(stmt);})* <RPAREN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return new Record(assigns);}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Function Function() :
{/*@bgen(jjtree) Function */
    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IASTType def;
    List<IASTStatement> stmts;
}
{/*@bgen(jjtree) Function */
   try {
/*@egen*/
   <FUNC> def = FunctionType()
    <LCURLY>
        stmts = FunctionStatements()
    <RCURLY>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {return new Function(def, stmts);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

Return Return() :
{/*@bgen(jjtree) Return */
   SimpleNode jjtn000 = new SimpleNode(JJTRETURN);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
    // Every function needs to have a return statement, at least one, that matches the functions
    // return type, so that's where I get the return type from
   // What is this though? A return key word followed by an expression
   IASTExpr expr;
}
{/*@bgen(jjtree) Return */
   try {
/*@egen*/
   <RETURN> expr = Expression()/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/

   {return new Return(expr);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}